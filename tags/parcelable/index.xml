<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Parcelable on Takuron</title><link>https://takuron.com/tags/parcelable/</link><description>Recent content in Parcelable on Takuron</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 23 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://takuron.com/tags/parcelable/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 13中使用Intent传输Parcelable对象为空的解决方式</title><link>https://takuron.com/post/id0025/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://takuron.com/post/id0025/</guid><description>&lt;img src="https://img.takuron.com/20250827/1e7bc2d1c52123042ccb528e7263e7ca.webp" alt="Featured image of post Android 13中使用Intent传输Parcelable对象为空的解决方式" />&lt;h2 id="背景介绍">背景介绍
&lt;/h2>&lt;h3 id="intent对象传递与序列化">Intent对象传递与序列化
&lt;/h3>&lt;p>为了在Android各大组件之间通信跳转，Intent是最常用的通信手段。其中我们可以在其中的extra里面添加一些简单数据随其传递到下一个组件。为了向其中写入对象数据，我们需要将对象转变成可以保存和传输的二进制格式，即序列化过程。Android Intent允许传递继承Serializable和Parcelable的可序列化对象。
Serializable为Java原生的可序列化接口，只需继承自空的Serializable接口即可实现整个对象的序列化，但其序列化的实现使用了Java的反射机制且会对整个类的全部数据进行序列化，效率非常低。Parcelable则是Android专门设计的序列化接口，其需要自行实现序列化和反序列化的方法，其优点自然是&lt;a class="link" href="go?url=https://www.developerphil.com/parcelable-vs-serializable/" >整体效率可以接近十倍于Serializable&lt;/a>，缺点自然是实现的时候需要写大量格式化的代码，以下是java中的一个例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">static class Skill implements Parcelable {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> String name;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean programmingRelated;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill(Parcel in) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.name = in.readString();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.programmingRelated = (in.readInt() == 1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> void writeToParcel(Parcel dest, int flags) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dest.writeString(name);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dest.writeInt(programmingRelated ? 1 : 0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> static final Parcelable.Creator&amp;lt;Skill&amp;gt; CREATOR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> = new Parcelable.Creator&amp;lt;Skill&amp;gt;() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill createFromParcel(Parcel in) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return new Skill(in);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill[] newArray(int size) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return new Skill[size];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> };
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int describeContents() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="kotlin的优化">Kotlin的优化
&lt;/h3>&lt;p>Kotlin原生引入了data class，并且得益于gradle强大的插件系统。这解决了上面Parcelable接口最大的缺点，我们可以用插件快速为开发中常用的data类实现Parcelable序列化方法，首先在build.gradle里引入插件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">plugins {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> id(&amp;#34;kotlin-parcelize&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后对需要实现Parcelable接口的数据类使用注释即可：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@Keep
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@Parcelize
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data class PaoModel(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> val pao_name: String,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> val pao_url:String
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">): Parcelable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="api33的改动">API33的改动
&lt;/h3>&lt;p>Api33以前无论读取那种序列化对象都是直接根据key来获得对象后强转：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">val a:A = activity.intent.extras?.getParcelable(&amp;#34;key1&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val b:B = activity.intent.extras?.getSerializable(&amp;#34;key2&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但这样是类型不安全的，为了解决这个问题，Api33以后弃用了上述的方法，改为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">val a = activity.intent.extras?.getParcelable(&amp;#34;key1&amp;#34;,A::class.java)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val b = activity.intent.extras?.getSerializable(&amp;#34;key2&amp;#34;,B::class.java)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="问题现象">问题现象
&lt;/h2>&lt;p>在实际开发中我使用了Activity A B C，A B两个Activity为唯一跳转Activity C的路径并向其传递了需要展示的对象信息x，接收intent的数据的代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if(Build.VERSION.SDK_INT&amp;gt;=Build.VERSION_CODES.TIRAMISU)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!getParcelable(AppInfo.INTENT_KEY_RENEYE,LgroModel::class.java)!!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!.getParcelable&amp;lt;LgroModel&amp;gt;(AppInfo.INTENT_KEY_RENEYE)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在测试的时候未发现任何问题，于是混淆打包release，出事了，提示空指针。&lt;/p>
&lt;p>首先考虑混淆导致data类错误和强制非空转换的逻辑问题，但查了半天该keep的都正常keep，逻辑在debug包下无论怎么点都不会有问题。尝试打印传入对象，在release包下依然有效。尝试传递字符串，传递正常。于是问题就变成了为何intent传递对象失效。&lt;/p>
&lt;h2 id="解决">解决
&lt;/h2>&lt;p>问题回到了获取Parcelable对象本身，此时看到为了适配新api做的分支判断，马上掏了个Android 11的手机测试，一切正常，问题看样子出在了新的方法上，遂根据关键词搜索，找到了&lt;a class="link" href="go?url=https://stackoverflow.com/questions/76067109/getparcelable-crashes-due-to-null-iftable-in-agp-8" >Stack Overflow上的这篇文章&lt;/a>,真相大白，解决方案翻译如下：&lt;/p>
&lt;blockquote>
&lt;p>我认为这个崩溃是由两个不幸的因素组合在一起引起的。
AGP 8 默认启用了 R8 的完整模式。R8 的完整模式会剥离默认构造函数并执行更激进的优化。在 API 33 中引入的新的 getParcelable(String, Class) 方法存在一些缺陷，如果 Parcelable 没有以特定方式定义，就会出现问题。&lt;a class="link" href="go?url=https://issuetracker.google.com/issues/274185314" >相关错误的文档&lt;/a>
看起来 getParcelable(String, Class) 的脆弱实现和 R8 对某些代码进行优化导致了这个崩溃。目前的解决方法似乎是在 API 33 中使用旧的 getParcelable(String) 方法。Google 表示他们已经在 API 34 中修复了 getParcelable(String, Class) 的问题。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>更新：androidx.core:core-ktx:1.10.0 包含了对此问题的修复。它包含了 BundleCompat.getParcelable(Bundle, String, Class)，该方法仅在 Android U 及以上版本上调用新的 getParcelable(Bundle, Class) 函数。&lt;/p>&lt;/blockquote>
&lt;p>这个问题只会在使用R8混淆之后才会出现且较难定位。所以为了解决这个问题，现在建议升级AndroidX之后使用其中的方法来获取Parcelable对象。故修改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if(Build.VERSION.SDK_INT&amp;gt;=Build.VERSION_CODES.TIRAMISU)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = BundleCompat.getParcelable(ac.intent.extras!!,AppInfo.INTENT_KEY_RENEYE,LgrolrModel::class.java)!!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!.getParcelable&amp;lt;LgrolrModel&amp;gt;(AppInfo.INTENT_KEY_RENEYE)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>（后来发现用了兼容库版本判断也是多余的）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">historyData = BundleCompat.getParcelable(ac.intent.extras!!,AppInfo.INTENT_KEY_RENEYE,LgrolrModel::class.java)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>问题解决&lt;/p></description></item></channel></rss>