<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android开发 on Takuron</title><link>https://takuron.com/categories/android%E5%BC%80%E5%8F%91/</link><description>Recent content in Android开发 on Takuron</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 23 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://takuron.com/categories/android%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 13中使用Intent传输Parcelable对象为空的解决方式</title><link>https://takuron.com/post/id0025/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://takuron.com/post/id0025/</guid><description>&lt;img src="https://img.takuron.com/20250827/1e7bc2d1c52123042ccb528e7263e7ca.webp" alt="Featured image of post Android 13中使用Intent传输Parcelable对象为空的解决方式" />&lt;h2 id="背景介绍">背景介绍
&lt;/h2>&lt;h3 id="intent对象传递与序列化">Intent对象传递与序列化
&lt;/h3>&lt;p>为了在Android各大组件之间通信跳转，Intent是最常用的通信手段。其中我们可以在其中的extra里面添加一些简单数据随其传递到下一个组件。为了向其中写入对象数据，我们需要将对象转变成可以保存和传输的二进制格式，即序列化过程。Android Intent允许传递继承Serializable和Parcelable的可序列化对象。
Serializable为Java原生的可序列化接口，只需继承自空的Serializable接口即可实现整个对象的序列化，但其序列化的实现使用了Java的反射机制且会对整个类的全部数据进行序列化，效率非常低。Parcelable则是Android专门设计的序列化接口，其需要自行实现序列化和反序列化的方法，其优点自然是&lt;a class="link" href="go?url=https://www.developerphil.com/parcelable-vs-serializable/" >整体效率可以接近十倍于Serializable&lt;/a>，缺点自然是实现的时候需要写大量格式化的代码，以下是java中的一个例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">static class Skill implements Parcelable {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> String name;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean programmingRelated;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill(Parcel in) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.name = in.readString();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.programmingRelated = (in.readInt() == 1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> void writeToParcel(Parcel dest, int flags) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dest.writeString(name);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dest.writeInt(programmingRelated ? 1 : 0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> static final Parcelable.Creator&amp;lt;Skill&amp;gt; CREATOR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> = new Parcelable.Creator&amp;lt;Skill&amp;gt;() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill createFromParcel(Parcel in) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return new Skill(in);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skill[] newArray(int size) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return new Skill[size];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> };
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int describeContents() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="kotlin的优化">Kotlin的优化
&lt;/h3>&lt;p>Kotlin原生引入了data class，并且得益于gradle强大的插件系统。这解决了上面Parcelable接口最大的缺点，我们可以用插件快速为开发中常用的data类实现Parcelable序列化方法，首先在build.gradle里引入插件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">plugins {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> id(&amp;#34;kotlin-parcelize&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后对需要实现Parcelable接口的数据类使用注释即可：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@Keep
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@Parcelize
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data class PaoModel(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> val pao_name: String,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> val pao_url:String
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">): Parcelable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="api33的改动">API33的改动
&lt;/h3>&lt;p>Api33以前无论读取那种序列化对象都是直接根据key来获得对象后强转：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">val a:A = activity.intent.extras?.getParcelable(&amp;#34;key1&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val b:B = activity.intent.extras?.getSerializable(&amp;#34;key2&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但这样是类型不安全的，为了解决这个问题，Api33以后弃用了上述的方法，改为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">val a = activity.intent.extras?.getParcelable(&amp;#34;key1&amp;#34;,A::class.java)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val b = activity.intent.extras?.getSerializable(&amp;#34;key2&amp;#34;,B::class.java)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="问题现象">问题现象
&lt;/h2>&lt;p>在实际开发中我使用了Activity A B C，A B两个Activity为唯一跳转Activity C的路径并向其传递了需要展示的对象信息x，接收intent的数据的代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if(Build.VERSION.SDK_INT&amp;gt;=Build.VERSION_CODES.TIRAMISU)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!getParcelable(AppInfo.INTENT_KEY_RENEYE,LgroModel::class.java)!!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!.getParcelable&amp;lt;LgroModel&amp;gt;(AppInfo.INTENT_KEY_RENEYE)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在测试的时候未发现任何问题，于是混淆打包release，出事了，提示空指针。&lt;/p>
&lt;p>首先考虑混淆导致data类错误和强制非空转换的逻辑问题，但查了半天该keep的都正常keep，逻辑在debug包下无论怎么点都不会有问题。尝试打印传入对象，在release包下依然有效。尝试传递字符串，传递正常。于是问题就变成了为何intent传递对象失效。&lt;/p>
&lt;h2 id="解决">解决
&lt;/h2>&lt;p>问题回到了获取Parcelable对象本身，此时看到为了适配新api做的分支判断，马上掏了个Android 11的手机测试，一切正常，问题看样子出在了新的方法上，遂根据关键词搜索，找到了&lt;a class="link" href="go?url=https://stackoverflow.com/questions/76067109/getparcelable-crashes-due-to-null-iftable-in-agp-8" >Stack Overflow上的这篇文章&lt;/a>,真相大白，解决方案翻译如下：&lt;/p>
&lt;blockquote>
&lt;p>我认为这个崩溃是由两个不幸的因素组合在一起引起的。
AGP 8 默认启用了 R8 的完整模式。R8 的完整模式会剥离默认构造函数并执行更激进的优化。在 API 33 中引入的新的 getParcelable(String, Class) 方法存在一些缺陷，如果 Parcelable 没有以特定方式定义，就会出现问题。&lt;a class="link" href="go?url=https://issuetracker.google.com/issues/274185314" >相关错误的文档&lt;/a>
看起来 getParcelable(String, Class) 的脆弱实现和 R8 对某些代码进行优化导致了这个崩溃。目前的解决方法似乎是在 API 33 中使用旧的 getParcelable(String) 方法。Google 表示他们已经在 API 34 中修复了 getParcelable(String, Class) 的问题。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>更新：androidx.core:core-ktx:1.10.0 包含了对此问题的修复。它包含了 BundleCompat.getParcelable(Bundle, String, Class)，该方法仅在 Android U 及以上版本上调用新的 getParcelable(Bundle, Class) 函数。&lt;/p>&lt;/blockquote>
&lt;p>这个问题只会在使用R8混淆之后才会出现且较难定位。所以为了解决这个问题，现在建议升级AndroidX之后使用其中的方法来获取Parcelable对象。故修改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if(Build.VERSION.SDK_INT&amp;gt;=Build.VERSION_CODES.TIRAMISU)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = BundleCompat.getParcelable(ac.intent.extras!!,AppInfo.INTENT_KEY_RENEYE,LgrolrModel::class.java)!!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> historyData = ac.intent.extras!!.getParcelable&amp;lt;LgrolrModel&amp;gt;(AppInfo.INTENT_KEY_RENEYE)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>（后来发现用了兼容库版本判断也是多余的）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">historyData = BundleCompat.getParcelable(ac.intent.extras!!,AppInfo.INTENT_KEY_RENEYE,LgrolrModel::class.java)!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>问题解决&lt;/p></description></item><item><title>Android studio 2.2.3默认项目状态栏层级错误的解决方案</title><link>https://takuron.com/post/id0003/</link><pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate><guid>https://takuron.com/post/id0003/</guid><description>&lt;p>最近在android studio里新建了一个项目，本来觉得as真的很人性化，给了这么多模板，还都带material design效果，可是当我编译完成后……&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/30/597d814a7fd92.png"
loading="lazy"
alt="597d814a7fd92.png"
>&lt;/p>
&lt;p>握草这是什么玩意，最简单的hello world都给我附赠个状态栏层级错误，强迫症表示上面的阴影真的是令人无法忍受啊。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/30/597d81cc78f57.gif"
loading="lazy"
alt="597d81cc78f57.gif"
>&lt;/p>
&lt;p>然后找解决方案，国内是完全没有这方面资料（至少我没找到）（国人果然对md还是非常冷淡），英语水平又呵呵的很，所以一等就是好几个月没有理这个bug。&lt;/p>
&lt;p>前几天和朋友聊起这个bug，他们建议我去stackoverflow 再找找。一开始我是拒绝的，因为我这访问sf奇慢（开网页分钟级），但当他替我搜到时，我就在感叹：国外人真会玩啊。&lt;/p>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/34891756/toolbars-shadow-on-status-bar-for-lollipop" target="_blank" rel="noopener"
>stackoverflow原文地址&lt;/a>&lt;/p>
&lt;p>国外dalao提供了四种解决方案，下面我写一下我亲试有效的两种：&lt;/p>
&lt;h5 id="1去除statusbarcolor">1.去除statusBarColor
&lt;/h5>&lt;p>关于这个属性，android官方文档是这么解释的&lt;/p>
&lt;blockquote>
&lt;p>To set a custom color for the status bar, use the android:statusBarColor attribute when you extend the material theme. By default, android:statusBarColor inherits the value of android:colorPrimaryDark.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>本人借助翻译软件的渣翻：要为状态栏设置自定义颜色，可以在扩展主题主题时使用android:statusBarColor属性。默认情况下,android:statusBarColor继承了android的值:colorPrimaryDark。&lt;/p>&lt;/blockquote>
&lt;p>也就是说，我们现在需要它是透明的。然而透明是android的默认选项，虽然根据回答者的意思是我们在代码里就设置的是透明，但这完全没有必要，所以，我们应该找到value-v21里的style.xml，把这行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;item name=&amp;#34;android:statusBarColor&amp;#34;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>去掉就OK了。&lt;/p>
&lt;h5 id="2外面加一个linearlayout">2.外面加一个LinearLayout
&lt;/h5>&lt;p>很玄的一个方法，然而的确是有效的，不做首要推荐。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/30/597d89a8f04cb.png"
loading="lazy"
alt="597d89a8f04cb.png"
>&lt;/p>
&lt;p>（由于简书和我的博客老抽，只好先截图了，具体的可以到原文里查看）&lt;/p>
&lt;p>以上两种方法处理之后界面就恢复正常了～&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/30/597d8a0b730c7.png"
loading="lazy"
alt="597d8a0b730c7.png"
>&lt;/p></description></item><item><title>aide安装m2repository库教程</title><link>https://takuron.com/post/id0001/</link><pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate><guid>https://takuron.com/post/id0001/</guid><description>&lt;p>android support一向是Google官方提供给开发者解决应用兼容性和提供官方工具的好东西，这些都打包存在m2repository中。aide支持这个库，不过由于万里长城的影响，aide内置下载是有一定问题的，这里讲讲如何不用梯子下载安装最新版m2repository。&lt;/p>
&lt;p>首先下载打包版本的m2repository，下载地址（推荐Google官方）：&lt;/p>
&lt;p>&lt;a class="link" href="https://dl-ssl.google.com/android/repository/android_m2repository_r47.zip" target="_blank" rel="noopener"
>Google官方（国内已经可用）&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://android-mirror.bugly.qq.com:8080/android/repository/android_m2repository_r47.zip" target="_blank" rel="noopener"
>腾讯的国内镜像&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://mirrors.neusoft.edu.cn/android/repository/android_m2repository_r47.zip" target="_blank" rel="noopener"
>外国镜像（非常非常慢）&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://pan.baidu.com/s/1qXD16RM" target="_blank" rel="noopener"
>百度网盘，提取码0202&lt;/a>&lt;/p>
&lt;p>下载完成后解压。注意：解压的时候最好选择“解压到当前目录”或“解压到指定目录”，如果没有这种选项下一步请保证选择的文件夹名字为“m2repository”。&lt;/p>
&lt;p>以下以es文件浏览器解压为例，请选择2、3项而不是第一项。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/25/59771cf2e708b.png"
loading="lazy"
alt="59771cf2e708b.png"
>&lt;/p>
&lt;p>解压后在aide中找到解压得到的文件夹，复制路径。&lt;/p>
&lt;p>再次提醒：一定要保证复制路径的是文件夹名字为“m2repository”的文件夹，如果不是，请往里面寻找。&lt;/p>
&lt;p>最后，在菜单里找到更多〉设置〉构建/运行〉maven仓库目录，把刚刚复制的路径粘贴进去即可。&lt;/p>
&lt;p>&lt;img src="https://ooo.0o0.ooo/2017/07/25/59771e30283c5.png"
loading="lazy"
alt="59771e30283c5.png"
>&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2017/07/25/59771e3d3cff5.png"
loading="lazy"
alt="59771e3d3cff5.png"
>&lt;/p>
&lt;p>再在项目中引用类似android support v4之类的库，可以看到项目已经正常了。&lt;/p></description></item></channel></rss>